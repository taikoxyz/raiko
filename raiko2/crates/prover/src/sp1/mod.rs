//! SP1 zkVM Prover for Raiko V2
//!
//! This module provides the SP1 prover implementation for generating
//! zero-knowledge proofs of Taiko block execution.

use alloy_primitives::B256;
use raiko2_primitives::{
    AggregationGuestInput, GuestInput, Proof, ProverConfig, ProverError, ProverResult,
};
use serde::{Deserialize, Serialize};
use tracing::info;

#[cfg(feature = "sp1")]
use sp1_sdk::{ProverClient, SP1ProofMode, SP1ProofWithPublicValues, SP1Stdin, SP1VerifyingKey};

// Generated ELF binaries from guest build
pub mod elf;

/// SP1 prover configuration parameters.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Sp1Config {
    /// Proof mode (Core, Compressed, Plonk).
    #[serde(default)]
    pub recursion: RecursionMode,
    /// Prover mode (Mock, Local, Network).
    pub prover: Option<ProverMode>,
    /// Whether to verify the proof after generation.
    #[serde(default = "default_true")]
    pub verify: bool,
}

fn default_true() -> bool {
    true
}

impl Default for Sp1Config {
    fn default() -> Self {
        Self {
            recursion: RecursionMode::Plonk,
            prover: None,
            verify: true,
        }
    }
}

/// SP1 proof recursion mode.
#[derive(Clone, Debug, Serialize, Deserialize, Default)]
#[serde(rename_all = "lowercase")]
pub enum RecursionMode {
    /// Core proof (no recursion).
    Core,
    /// Compressed proof.
    Compressed,
    /// Plonk proof (on-chain verifiable).
    #[default]
    Plonk,
}

#[cfg(feature = "sp1")]
impl From<RecursionMode> for SP1ProofMode {
    fn from(value: RecursionMode) -> Self {
        match value {
            RecursionMode::Core => SP1ProofMode::Core,
            RecursionMode::Compressed => SP1ProofMode::Compressed,
            RecursionMode::Plonk => SP1ProofMode::Plonk,
        }
    }
}

/// SP1 prover mode.
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq, Eq, Hash)]
#[serde(rename_all = "lowercase")]
pub enum ProverMode {
    /// Mock prover for testing.
    Mock,
    /// Local CPU prover.
    Local,
    /// Network prover (Succinct network).
    Network,
}

/// SP1 proof response.
#[derive(Clone, Serialize, Deserialize)]
pub struct Sp1Response {
    pub proof: Option<String>,
    pub vkey_hash: Option<String>,
    pub input: B256,
}

impl From<Sp1Response> for Proof {
    fn from(value: Sp1Response) -> Self {
        Self {
            proof: value.proof,
            quote: value.vkey_hash,
            input: Some(value.input),
            uuid: None,
            kzg_proof: None,
        }
    }
}

/// SP1 Prover for Shasta batch proofs.
pub struct Sp1Prover {
    config: Sp1Config,
}

impl Sp1Prover {
    /// Create a new SP1 prover with the given configuration.
    pub fn new(config: Sp1Config) -> Self {
        Self { config }
    }
}

#[cfg(feature = "sp1")]
#[async_trait::async_trait]
impl crate::Prover for Sp1Prover {
    async fn prove(&self, input: GuestInput, _config: &ProverConfig) -> ProverResult<Proof> {
        info!("Starting SP1 batch proof generation...");

        // Serialize input
        let mut stdin = SP1Stdin::new();
        stdin.write(&input);

        // Create prover client
        let client = ProverClient::from_env();

        // Use methods ELF (will be generated by build-guest.sh)
        let elf = elf::SP1_BATCH_ELF;

        // Setup proving key and verifying key
        let (pk, vk) = client.setup(elf);

        // Get proof mode
        let proof_mode: SP1ProofMode = self.config.recursion.clone().into();

        // Generate proof
        let proof = client
            .prove(&pk, &stdin)
            .mode(proof_mode)
            .run()
            .map_err(|e| {
                tracing::error!("Failed to generate SP1 batch proof: {:?}", e);
                ProverError::GuestError(format!("SP1 batch proof generation failed: {}", e))
            })?;

        info!("SP1 batch proof generated successfully");

        // Verify proof if configured
        if self.config.verify {
            client.verify(&proof, &vk).map_err(|e| {
                tracing::error!("Failed to verify SP1 batch proof: {:?}", e);
                ProverError::GuestError(format!("SP1 batch proof verification failed: {}", e))
            })?;
            info!("SP1 batch proof verified successfully");
        }

        // Encode proof
        let proof_bytes = bincode::serialize(&proof).map_err(|e| {
            ProverError::GuestError(format!("Failed to serialize proof: {}", e))
        })?;

        Ok(Sp1Response {
            proof: Some(alloy_primitives::hex::encode_prefixed(&proof_bytes)),
            vkey_hash: Some(vk.bytes32()),
            input: B256::default(),
        }
        .into())
    }

    async fn aggregate(
        &self,
        input: AggregationGuestInput,
        _config: &ProverConfig,
    ) -> ProverResult<Proof> {
        info!(
            "Starting SP1 aggregation proof generation with {} proofs...",
            input.proofs.len()
        );

        // TODO: Implement aggregation proof generation
        // This requires extracting SP1 proofs from input and building
        // an aggregation proof using the SP1 aggregation guest.

        Err(ProverError::GuestError(
            "SP1 aggregation not yet implemented in V2".to_string(),
        ))
    }
}

#[cfg(not(feature = "sp1"))]
#[async_trait::async_trait]
impl crate::Prover for Sp1Prover {
    async fn prove(&self, _input: GuestInput, _config: &ProverConfig) -> ProverResult<Proof> {
        Err(ProverError::GuestError(
            "SP1 feature not enabled".to_string(),
        ))
    }

    async fn aggregate(
        &self,
        _input: AggregationGuestInput,
        _config: &ProverConfig,
    ) -> ProverResult<Proof> {
        Err(ProverError::GuestError(
            "SP1 feature not enabled".to_string(),
        ))
    }
}
