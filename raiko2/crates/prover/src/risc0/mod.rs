//! RISC0 zkVM Prover for Raiko V2
//!
//! This module provides the RISC0 prover implementation for generating
//! zero-knowledge proofs of Taiko block execution.

use alloy_primitives::B256;
use raiko2_primitives::{
    AggregationGuestInput, GuestInput, Proof, ProverConfig, ProverError, ProverResult,
};
use serde::{Deserialize, Serialize};
use tracing::info;

#[cfg(feature = "risc0")]
use risc0_zkvm::{ExecutorEnv, ProverOpts, default_prover, serde::to_vec};

// Generated methods from guest build
pub mod methods;

/// RISC0 prover configuration parameters.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Risc0Config {
    /// Whether to use Bonsai proving service.
    pub bonsai: bool,
    /// Whether to generate SNARK proof.
    pub snark: bool,
    /// Whether to enable profiling.
    pub profile: bool,
    /// Execution power of 2 (for cycle limit).
    pub execution_po2: u32,
}

impl Default for Risc0Config {
    fn default() -> Self {
        Self {
            bonsai: true,
            snark: true,
            profile: false,
            execution_po2: 20,
        }
    }
}

/// RISC0 proof response.
#[derive(Clone, Serialize, Deserialize)]
pub struct Risc0Response {
    pub proof: String,
    pub receipt: String,
    pub uuid: String,
    pub input: B256,
}

impl From<Risc0Response> for Proof {
    fn from(value: Risc0Response) -> Self {
        Self {
            proof: Some(value.proof),
            quote: Some(value.receipt),
            input: Some(value.input),
            uuid: Some(value.uuid),
            kzg_proof: None,
        }
    }
}

/// RISC0 Prover for Shasta batch proofs.
pub struct Risc0Prover {
    config: Risc0Config,
}

impl Risc0Prover {
    /// Create a new RISC0 prover with the given configuration.
    pub fn new(config: Risc0Config) -> Self {
        Self { config }
    }
}

#[cfg(feature = "risc0")]
#[async_trait::async_trait]
impl crate::Prover for Risc0Prover {
    async fn prove(&self, input: GuestInput, _config: &ProverConfig) -> ProverResult<Proof> {
        let _encoded_input = to_vec(&input).map_err(|e| {
            ProverError::GuestError(format!("Failed to serialize input: {}", e))
        })?;

        let env = ExecutorEnv::builder()
            .write(&input)
            .map_err(|e| ProverError::GuestError(format!("Failed to write input: {}", e)))?
            .build()
            .map_err(|e| ProverError::GuestError(format!("Failed to build env: {}", e)))?;

        let opts = if self.config.snark {
            ProverOpts::groth16()
        } else {
            ProverOpts::default()
        };

        // Use methods ELF (will be generated by build-guest.sh)
        let elf = methods::RISC0_BATCH_ELF;

        info!("Starting RISC0 batch proof generation...");
        let receipt = default_prover()
            .prove_with_opts(env, elf, &opts)
            .map_err(|e| {
                tracing::error!("Failed to generate RISC0 batch proof: {:?}", e);
                ProverError::GuestError(format!("RISC0 batch proof generation failed: {}", e))
            })?
            .receipt;

        info!(
            "Generated batch receipt journal: {:?}",
            alloy_primitives::hex::encode_prefixed(receipt.journal.bytes.clone())
        );

        Ok(Risc0Response {
            proof: alloy_primitives::hex::encode_prefixed(&receipt.journal.bytes),
            receipt: serde_json::to_string(&receipt).unwrap_or_default(),
            uuid: String::new(),
            input: B256::default(),
        }
        .into())
    }

    async fn aggregate(
        &self,
        input: AggregationGuestInput,
        _config: &ProverConfig,
    ) -> ProverResult<Proof> {
        info!(
            "Starting RISC0 aggregation proof generation with {} proofs...",
            input.proofs.len()
        );

        // TODO: Implement aggregation proof generation
        // This requires extracting receipts from input proofs and building
        // an aggregation proof using the RISC0 aggregation guest.

        Err(ProverError::GuestError(
            "RISC0 aggregation not yet implemented in V2".to_string(),
        ))
    }
}

#[cfg(not(feature = "risc0"))]
#[async_trait::async_trait]
impl crate::Prover for Risc0Prover {
    async fn prove(&self, _input: GuestInput, _config: &ProverConfig) -> ProverResult<Proof> {
        Err(ProverError::GuestError(
            "RISC0 feature not enabled".to_string(),
        ))
    }

    async fn aggregate(
        &self,
        _input: AggregationGuestInput,
        _config: &ProverConfig,
    ) -> ProverResult<Proof> {
        Err(ProverError::GuestError(
            "RISC0 feature not enabled".to_string(),
        ))
    }
}
